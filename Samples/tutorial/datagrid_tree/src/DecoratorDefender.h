/*
 * Copyright (c) 2006 - 2008
 * Wandering Monster Studios Limited
 *
 * Any use of this program is governed by the terms of Wandering Monster
 * Studios Limited's Licence Agreement included with this program, a copy
 * of which can be obtained by contacting Wandering Monster Studios
 * Limited at info@wanderingmonster.co.nz.
 *
 */

#ifndef DECORATORDEFENDER_H
#define DECORATORDEFENDER_H

#include <Rocket/Core/Decorator.h>

/**
	A decorator that displays the defender in the colour of its "colour" property.
	@author Robert Curry
 */

class DecoratorDefender : public Rocket::Core::Decorator
{
public:
	virtual ~DecoratorDefender();

	bool Initialise(const Rocket::Core::String& image_source, const Rocket::Core::String& image_path);

	/// Called on a decorator to generate any required per-element data for a newly decorated element.
	/// @param element[in] The newly decorated element.
	/// @return A handle to a decorator-defined data handle, or NULL if none is needed for the element.
	virtual Rocket::Core::DecoratorDataHandle GenerateElementData(Rocket::Core::Element* element);
	/// Called to release element data generated by this decorator.
	/// @param element_data[in] The element data handle to release.
	virtual void ReleaseElementData(Rocket::Core::DecoratorDataHandle element_data);

	/// Called to render the decorator on an element.
	/// @param element[in] The element to render the decorator on.
	/// @param element_data[in] The handle to the data generated by the decorator for the element.
	virtual void RenderElement(Rocket::Core::Element* element, Rocket::Core::DecoratorDataHandle element_data);

private:
	int image_index;
};

#endif
